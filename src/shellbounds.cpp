#include "shellbounds.h"
#include "adjacenttriangles.h"

void generateShellBoundSimple(const MatrixXu &bF, const MatrixXf &bV, const MatrixXf &oV, MatrixXu &boundF, MatrixXf &boundV) {
	boundV.resize(bV.rows(), bV.cols() + oV.cols());
	memcpy(boundV.data(), bV.data(), sizeof(bV(0, 0)) * bV.size());
	memcpy(reinterpret_cast<uint8_t *>(boundV.data()) + sizeof(bV(0, 0)) * bV.size(), oV.data(), sizeof(oV(0, 0)) * oV.size());

	// Flip the base surface to make the face normals point outside the bound
	MatrixXu bF_f = bF;
	for (uint32_t f = 0; f < bF_f.cols(); ++f)
		std::swap(bF_f(1, f), bF_f(2, f));

	MatrixXu oF;
	oF.resize(bF.rows(), bF.cols());
	oF.setConstant(bV.cols());
	oF += bF;

	EdgeToAdjacentTrianglesMap adjacentMap;
	buildEdgeAdjacentTrianglesTable(bF, adjacentMap);

	std::vector<Vector3u> primF;	// prim faces generated by linking base mesh's bounding edges' points to offset mesh's

	for (uint32_t f = 0; f < bF_f.cols(); ++f) {
		uint32_t points[3] = { bF(0, f), bF(1, f), bF(2, f) };

		for (int i = 0; i < 3; ++i) {
			int j = (i == 2 ? 0 : i + 1);
			if (lookupEdgeAdjacentTriangle(f, points[i], points[j], adjacentMap) == -1) {
				// this is a bounding edge, generate new prism faces
				Vector3u tri0, tri1;
				tri0 << bF(j, f), oF(i, f), bF(i, f);
				tri1 << bF(j, f), oF(j, f), oF(i, f);
				primF.push_back(tri0);
				primF.push_back(tri1);
			}
		}
	}

	// The final bound consists of flipped base surface, offset surface and prim triangles
	boundF.resize(bF_f.rows(), bF_f.cols() + oF.cols() + primF.size());

	for (uint32_t f = 0; f < bF_f.cols(); ++f) {
		boundF.col(2 * f) = bF_f.col(f);
		boundF.col(2 * f + 1) = oF.col(f);
	}

	uint32_t offsetBytes = sizeof(uint32_t) * (bF_f.size() + oF.size());
	memcpy(reinterpret_cast<uint8_t *>(boundF.data()) + offsetBytes, primF.data(), sizeof(uint32_t) * 3 * primF.size());
}