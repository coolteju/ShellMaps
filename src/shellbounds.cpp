#include "shellbounds.h"
#include "adjacenttriangles.h"

void generateShellBoundSimple(const MatrixXu &bF, const MatrixXf &bV, const MatrixXf &oV, MatrixXu &boundF, MatrixXf &boundV) {
	boundV.resize(bV.rows(), bV.cols() + oV.cols());
	memcpy(boundV.data(), bV.data(), sizeof(bV(0, 0)) * bV.size());
	memcpy(reinterpret_cast<uint8_t *>(boundV.data()) + sizeof(bV(0, 0)) * bV.size(), oV.data(), sizeof(oV(0, 0)) * oV.size());

	MatrixXu oF;
	oF.resize(bF.rows(), bF.cols());
	oF.setConstant(bV.cols());
	oF += bF;

	EdgeToAdjacentTrianglesMap adjacentMap;
	buildEdgeAdjacentTrianglesTable(bF, adjacentMap);

	std::vector<Vector3u> primF;	// prim faces generated by linking base mesh's bounding edges' points to offset mesh's

	for (uint32_t f = 0; f < bF.cols(); ++f) {
		uint32_t points[3] = { bF(0, f), bF(1, f), bF(2, f) };

		for (int i = 0; i < 3; ++i) {
			int j = (i == 2 ? 0 : i + 1);
			if (lookupEdgeAdjacentTriangle(f, points[i], points[j], adjacentMap) == -1) {
				// this is a bounding edge, generate new prism faces
				Vector3u tri0, tri1;
				tri0 << bF(i, f), oF(j, f), bF(j, f);
				tri1 << bF(i, f), oF(i, f), oF(j, f);
				primF.push_back(tri0);
				primF.push_back(tri1);
			}
		}
	}

	boundF.resize(bF.rows(), bF.cols() + oF.cols() + primF.size());

	uint32_t offsetBytes = 0;
	memcpy(boundF.data(), bF.data(), sizeof(uint32_t) * bF.size());
	offsetBytes += sizeof(uint32_t) * bF.size();
	memcpy(reinterpret_cast<uint8_t *>(boundF.data()) + offsetBytes, oF.data(), sizeof(uint32_t) * oF.size());
	offsetBytes += sizeof(uint32_t) * oF.size();
	memcpy(reinterpret_cast<uint8_t *>(boundF.data()) + offsetBytes, primF.data(), sizeof(uint32_t) * 3 * primF.size());
}